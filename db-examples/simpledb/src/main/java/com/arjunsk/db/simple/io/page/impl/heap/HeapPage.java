package com.arjunsk.db.simple.io.page.impl.heap;

import com.arjunsk.db.simple.db.BufferPool;
import com.arjunsk.db.simple.db.Database;
import com.arjunsk.db.simple.io.page.Page;
import com.arjunsk.db.simple.io.page.PageId;
import com.arjunsk.db.simple.io.record.RecordId;
import com.arjunsk.db.simple.io.tuple.Tuple;
import com.arjunsk.db.simple.io.tuple.desc.TupleDesc;
import com.arjunsk.db.simple.io.tuple.fileds.Field;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.text.ParseException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Each instance of HeapPage stores data for one page of HeapFiles and implements the Page interface
 * that is used by BufferPool.
 *
 * @see com.arjunsk.db.simple.io.file.impl.heap.HeapFile
 * @see BufferPool
 */
public class HeapPage implements Page {

  private final HeapPageId heapPageId;
  private final TupleDesc tupleDesc;
  private final byte[] header;
  private final int numSlots;

  private Tuple[] tuples;

  /**
   * Create a HeapPage from a set of bytes of data read from disk. The format of a HeapPage is a set
   * of header bytes indicating the slots of the page that are in use, some number of tuple slots.
   *
   * <p>Specifically, the number of tuples is equal to: <code>
   * floor((BufferPool.PAGE_SIZE*8) / (tuple size * 8 + 1))</code>
   *
   * <p>where tuple size is the size of tuples in this database table, which can be determined via
   * {@link com.arjunsk.db.simple.db.Catalog#getTupleDesc}.
   *
   * <p>The number of 8-bit header words is equal to: <code>ceiling(no. tuple slots / 8) </code>
   *
   * <p>
   *
   * @see Database#getCatalog
   * @see com.arjunsk.db.simple.db.Catalog#getTupleDesc
   * @see BufferPool#PAGE_SIZE
   */
  public HeapPage(HeapPageId id, byte[] data) {
    this.heapPageId = id;
    this.tupleDesc = Database.getCatalog().getTupleDesc(id.getTableId());
    this.numSlots = getNumTuples();
    this.header = new byte[getHeaderSize()];

    try (DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data))) {
      // Header
      for (int i = 0; i < header.length; i++) header[i] = dis.readByte();

      // Data
      tuples = new Tuple[numSlots];
      for (int i = 0; i < tuples.length; i++) tuples[i] = readNextTuple(dis, i);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  @Override
  public PageId getId() {
    return heapPageId;
  }

  /**
   * Generates a byte array representing the contents of this page. Used to serialize this page to
   * disk.
   *
   * <p>The invariant here is that it should be possible to pass the byte array generated by
   * getPageData to the HeapPage constructor and have it produce an identical HeapPage object.
   *
   * @return A byte array correspond to the bytes of this page.
   * @see #HeapPage
   */
  @Override
  public byte[] getPageData() {
    int len = BufferPool.PAGE_SIZE;
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(len);
    DataOutputStream dos = new DataOutputStream(byteArrayOutputStream);

    // create the header of the page
    for (int i = 0; i < header.length; i++) {
      try {
        dos.writeByte(header[i]);
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    // create the tuples
    for (int i = 0; i < tuples.length; i++) {

      // empty slot
      if (isSlotVacant(i)) {
        for (int j = 0; j < tupleDesc.getSize(); j++) {
          try {
            dos.writeByte(0);
          } catch (IOException e) {
            e.printStackTrace();
          }
        }
        continue;
      }

      // non-empty slot
      for (int j = 0; j < tupleDesc.numFields(); j++) {
        Field field = tuples[i].getField(j);
        try {
          field.serialize(dos);
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }

    // padding
    int zeroLen = BufferPool.PAGE_SIZE - (header.length + tupleDesc.getSize() * tuples.length);
    byte[] zeroes = new byte[zeroLen];
    try {
      dos.write(zeroes, 0, zeroLen);
    } catch (IOException e) {
      e.printStackTrace();
    }

    try {
      dos.flush();
    } catch (IOException e) {
      e.printStackTrace();
    }

    return byteArrayOutputStream.toByteArray();
  }

  private int getNumTuples() {
    if (numSlots != 0) {
      return numSlots;
    }
    return (BufferPool.PAGE_SIZE * 8) / (tupleDesc.getSize() * 8 + 1);
  }

  public int getNumEmptySlots() {
    int emptySlots = 0;
    for (int i = 0; i < getNumTuples(); i++) {
      if (isSlotVacant(i)) {
        emptySlots++;
      }
    }
    return emptySlots;
  }

  private int getHeaderSize() {
    return (int) Math.ceil(getNumTuples() / 8.0);
  }

  private Tuple readNextTuple(DataInputStream dis, int slotId) throws NoSuchElementException {

    if (isSlotVacant(slotId)) {
      for (int i = 0; i < tupleDesc.getSize(); i++) {
        try {
          dis.readByte();
        } catch (IOException e) {
          throw new NoSuchElementException("error reading empty tuple");
        }
      }
      return null;
    }

    // read fields in the tuple
    Tuple tuple = new Tuple(tupleDesc);
    RecordId recordId = new RecordId(heapPageId, slotId);
    tuple.setRecordId(recordId);
    try {
      for (int fieldIndex = 0; fieldIndex < tupleDesc.numFields(); fieldIndex++) {
        Field fieldValue = tupleDesc.getFieldType(fieldIndex).parse(dis);
        tuple.setField(fieldIndex, fieldValue);
      }
    } catch (ParseException e) {
      e.printStackTrace();
      throw new NoSuchElementException("parsing error!");
    }

    return tuple;
  }

  public boolean isSlotVacant(int i) {
    int byteNum = i / 8;
    int posInByte = i % 8;
    return !isOne(header[byteNum], posInByte);
  }

  private boolean isOne(byte target, int posInByte) {
    return (byte) (target << (7 - posInByte)) < 0;
  }

  public Iterator<Tuple> iterator() {
    return new UsedTupleIterator();
  }

  private class UsedTupleIterator implements Iterator<Tuple> {

    private final int usedTuplesNum = getNumTuples() - getNumEmptySlots();
    private int pos = 0;
    private int index = 0;

    @Override
    public boolean hasNext() {
      return index < getNumTuples() && pos < usedTuplesNum;
    }

    @Override
    public Tuple next() {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }

      while (isSlotVacant(index)) index++;
      pos++;
      return tuples[index++];
    }
  }
}
